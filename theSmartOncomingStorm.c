#pragma config(Sensor, in1,    pot,            sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  PuffyPanda,     sensorDigitalOut)
#pragma config(Sensor, dgtl9,  redCloseBut,    sensorTouch)
#pragma config(Sensor, dgtl10, redFarBut,      sensorTouch)
#pragma config(Sensor, dgtl11, blueCloseBut,   sensorTouch)
#pragma config(Sensor, dgtl12, blueFarBut,     sensorTouch)
#pragma config(Motor,  port1,           RightWinch,    tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           FrontRight,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           RightArm,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           BackRight,     tmotorVex393_MC29, PIDControl, encoderPort, dgtl3)
#pragma config(Motor,  port5,           RightIntake,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           LeftIntake,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           BackLeft,      tmotorVex393_MC29, PIDControl, encoderPort, dgtl1)
#pragma config(Motor,  port8,           LeftArm,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           FrontLeft,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          LeftWinch,     tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#include "PidLib.c"

//global to hold arm pid controller pointer
pidController *arm_pid;

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{

	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = false;
stopAllTasks();
allMotorsOff();//ivities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}
int phase = 0; //Values are 0-3, 0 = wait, 1 = left, 2 = right, 3 = pick up sack, return home.
int upperArmPosition = 1750;
int lowerArmPosition = 80;
int middleArmPosition = 1000;
#define REDC 1
#define REDF 2
#define BLUEC 3
#define BLUEF 4
short arm_drive;
short intake_drive;
long drive_l_motor, drive_r_motor;
/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	// .....................................................................................
	// Insert user code here.
	// .....................................................................................

	AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task ArmControl()
{
	while(1)
	{
		if(arm_pid != NULL )
		{
			//Update PID Control
			PidControllerUpdate(arm_pid);

			//Driving the Motor
			SetMotor( armLeft, arm_pid->drive_cmd);
			SetMotor( armRight, arm_pid->drive_cmd);
		}

		wait1Msec(25);
	}
}

void
ArmSetPosition(short position)
{
	if(arm_pid != NULL)
		arm_pid->target_value = position;
}

/*-----------------------------------------------------------------------------*/
/*  Wait for arm to be in position                                             */
/*-----------------------------------------------------------------------------*/

short
ArmWaitInPosition( short timeout = 3000 )
{
	// default is 3 seconds
	short   count = timeout;

	while(count >= 0 )
	{
		// wait so that pid has calculated error
		wait1Msec(50);

		// Check the pid error for the arm
		if( (abs(arm_pid->error) < 50 ) )
			return(1);

		// decrease timeout
		count -= 50;
	}

	return(0);
}

task usercontrol(){
	StartTask(ArmControl);
	arm_pid = PidControllerInit(0.004, 0.0, 0.01, pot, 0);

	while (1){
		FrontLeft = vexRT[Ch3];
		FrontRight = vexRT[Ch2];
		BackLeft = vexRT[Ch3];
		BackRight = vexRT[Ch2];


		//Creating variables to hvalue of controller
		drive_l_motor = vexRT[Ch3];
		drive_r_motor = vexRT[Ch2];

		//Drivetrain code
		SetMotor(frontLeft, drive_l_motor);
		SetMotor(backLeft, drive_l_motor);
		SetMotor(frontRight, drive_r_motor);
		SetMotor(backRight, drive_r_motor);

		//intake

		if(vexRT[Btn5UXmtr2])
			intake_drive = 127;
		else
			if(vexRT[Btn5DXmtr2])
			intake_drive = -127;
		else
			intake_drive = 0;

		SetMotor(intakeLeft, intake_drive);
		SetMotor(intakeRight, intake_drive);

		if(vexRT[Btn8U]){
			motor[hangLeft] = 127;
			motor[hangRight] = 127;

		}

		else if(vexRT[Btn7L]){
			motor[hangLeft] = -127;
			motor[hangRight] = -127;
		}

		else{
			motor[hangLeft] = 0;
			motor[hangRight] = 0;
		}

		// 2nd Controller

		//Creating variable to hold arm's controller value
		arm_drive = vexRT[Ch2Xmtr2];

		if(vexRT[Btn6UXmtr2])
		{
			ArmSetPosition(upperArmPosition);
		}
		else if(vexRT[Btn6DXmtr2])
		{
			ArmSetPosition(middleArmPosition);
		}
		else
		{
			//Arm code
			SetMotor(armLeft, arm_drive);
			SetMotor(armRight, arm_drive);
		}

		wait1Msec(3);
	}
	// This is the main execution loop for the user control program. Each time through the loop
	// your program should update motor + servo values based on feedback from the joysticks.

	// .....................................................................................
	// Insert user code here. This is where you use the joystick values to update your motors, etc.
	// .....................................................................................
}
